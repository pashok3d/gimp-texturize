```
/* block.h */

#ifndef __BLOCK_H__
#define __BLOCK_H__

#include <stdlib.h>

template <class Type> class Block {
public:
  Block(int size, void (*err_function)(const char *) = NULL) { first = last = NULL; block_size = size; error_function = err_function; }
  ~Block() { while (first) { block *next = first -> next; delete first; first = next; } }

  Type *New(int num = 1) {
    Type *t;

    if (!last || last->current + num > last->last) {
      if (last && last->next) last = last -> next;
      else {
        block *next = (block *) new char [sizeof(block) + (block_size-1)*sizeof(Type)];
        if (!next) { if (error_function) (*error_function)("Not enough memory!"); exit(1); }
        if (last) last -> next = next;
        else first = next;
        last = next;
        last -> current = & ( last -> data[0] );
        last -> last = last -> current + block_size;
        last -> next = NULL;
      }
    }

    t = last -> current;
    last -> current += num;
    return t;
  }

  Type *ScanFirst() {
    scan_current_block = first;
    if (!scan_current_block) return NULL;
    scan_current_data = & ( scan_current_block -> data[0] );
    return scan_current_data ++;
  }

  Type *ScanNext() {
    if (scan_current_data >= scan_current_block -> current) {
      scan_current_block = scan_current_block -> next;
      if (!scan_current_block) return NULL;
      scan_current_data = & ( scan_current_block -> data[0] );
    }
    return scan_current_data ++;
  }

  void Reset() {
    block *b;
    if (!first) return;
    for (b=first; ; b=b->next) {
      b -> current = & ( b -> data[0] );
      if (b == last) break;
    }
    last = first;
  }

private:

  typedef struct block_st {
    Type *current, *last;
    struct block_st *next;
    Type data[1];
  } block;

  int block_size;
  block	*first;
  block	*last;

  block	*scan_current_block;
  Type *scan_current_data;

  void(*error_function)(const char *);
};

template <class Type> class DBlock {
public:
  DBlock(int size, void (*err_function)(const char *) = NULL) {
    first = NULL; first_free = NULL; block_size = size; error_function = err_function;
  }

  ~DBlock() { while (first) { block *next = first -> next; delete first; first = next; } }

  Type *New() {
    block_item *item;

    if (!first_free) {
      block *next = first;
      first = (block *) new char [sizeof(block) + (block_size-1)*sizeof(block_item)];
      if (!first) { if (error_function) (*error_function)("Not enough memory!"); exit(1); }
      first_free = & (first -> data[0] );
      for (item=first_free; item<first_free+block_size-1; item++)
        item -> next_free = item + 1;
      item -> next_free = NULL;
      first -> next = next;
    }

    item = first_free;
    first_free = item -> next_free;
    return (Type *) item;
  }
  
  void Delete(Type *t) {
    ((block_item *) t) -> next_free = first_free;
    first_free = (block_item *) t;
  }

private:

  typedef union block_item_st {
    Type t;
    block_item_st *next_free;
  } block_item;

  typedef struct block_st {
    struct block_st *next;
    block_item data[1];
  } block;

  int block_size;
  block *first;
  block_item *first_free;

  void	(*error_function)(const char *);
};

#endif
```

```
/* compter.c */
#include <stdio.h>
#include "texturize.h"

// Counts the number of pixels that are already filled.
int count_filled_pixels(unsigned char **filled, int width_i, int height_i) {
  int x_i, y_i;
  int somme = 0;

  for (x_i = 0; x_i < width_i; x_i++) {
    for (y_i = 0; y_i < height_i; y_i++) {
      if (filled[x_i][y_i]) somme++;
    }
  }
  return somme;
}

// Finds the next pixel that needs to be filled.
int* pixel_to_fill(unsigned char **filled, int width_i, int height_i, int *resultat) {
  int x_i, y_i;

  for (y_i = 0; y_i < height_i; y_i++) {
    for (x_i = 0; x_i < width_i; x_i++) {
      if (!filled[x_i][y_i]) {
        resultat[0] = x_i;
        resultat[1] = y_i;
        return resultat;
      }
    }
  }
  return NULL;
}

// Quick and dirty implementation of x mod m assuming x isn't greater than
// 2 m.
int modulo(int x, int m) {
  int v = (x - (m * (x / m)));
  return (v >= 0)? v : v + m;
}
```

```
/* compter.h */
#include <glib.h>

int modulo(int x, int m);
```

```
/* graph.cpp */

#include <stdio.h>
#include "graph.h"

Graph::Graph(void (*err_function)(const char *)) {
  error_function = err_function;
  node_block = new Block<node>(NODE_BLOCK_SIZE, error_function);
  arc_block  = new Block<arc>(NODE_BLOCK_SIZE, error_function);
  flow = 0;
}

Graph::~Graph() {
  delete node_block;
  delete arc_block;
}

Graph::node_id Graph::add_node() {
  node *i = node_block -> New();

  i -> first = NULL;
  i -> tr_cap = 0;

  return (node_id) i;
}

void Graph::add_edge(node_id from, node_id to, captype cap, captype rev_cap) {
  arc *a, *a_rev;

  a = arc_block -> New(2);
  a_rev = a + 1;

  a -> sister = a_rev;
  a_rev -> sister = a;
  a -> next = ((node*)from) -> first;
  ((node*)from) -> first = a;
  a_rev -> next = ((node*)to) -> first;
  ((node*)to) -> first = a_rev;
  a -> head = (node*)to;
  a_rev -> head = (node*)from;
  a -> r_cap = cap;
  a_rev -> r_cap = rev_cap;
}

void Graph::set_tweights(node_id i, captype cap_source, captype cap_sink) {
  flow += (cap_source < cap_sink) ? cap_source : cap_sink;
  ((node*)i) -> tr_cap = cap_source - cap_sink;
}

void Graph::add_tweights(node_id i, captype cap_source, captype cap_sink) {
  captype delta = ((node*)i) -> tr_cap;
  if (delta > 0) cap_source += delta;
  else           cap_sink   -= delta;
  flow += (cap_source < cap_sink) ? cap_source : cap_sink;
  ((node*)i) -> tr_cap = cap_source - cap_sink;
}
```

```
/* graph.h */

#ifndef __GRAPH_H__
#define __GRAPH_H__

#include "block.h"

#define NODE_BLOCK_SIZE 512
#define ARC_BLOCK_SIZE 1024
#define NODEPTR_BLOCK_SIZE 128

class Graph {
public:
  typedef enum {
    SOURCE	= 0,
    SINK	= 1
  } termtype; /* terminals */

  typedef short captype;
  /* Type of total flow */
  typedef int flowtype;
  typedef void * node_id;

  Graph(void (*err_function)(const char *) = NULL);

  ~Graph();

  node_id add_node();

  void add_edge(node_id from, node_id to, captype cap, captype rev_cap);

  void set_tweights(node_id i, captype cap_source, captype cap_sink);

  void add_tweights(node_id i, captype cap_source, captype cap_sink);

  termtype what_segment(node_id i);

  flowtype maxflow();

private:
  struct arc_st;

  /* node structure */
  typedef struct node_st {
    arc_st			*first;		/* first outcoming arc */

    arc_st			*parent;	/* node's parent */
    node_st			*next;		/* pointer to the next active node
									   (or to itself if it is the last node in the list) */
    int				TS;			/* timestamp showing when DIST was computed */
    int				DIST;		/* distance to the terminal */
    short			is_sink;	/* flag showing whether the node is in the source or in the sink tree */

    captype			tr_cap;		/* if tr_cap > 0 then tr_cap is residual capacity of the arc SOURCE->node
									   otherwise         -tr_cap is residual capacity of the arc node->SINK */
  } node;

  /* arc structure */
  typedef struct arc_st {
    node_st			*head;		/* node the arc points to */
    arc_st			*next;		/* next arc with the same originating node */
    arc_st			*sister;	/* reverse arc */

    captype			r_cap;		/* residual capacity */
  } arc;

  /* 'pointer to node' structure */
  typedef struct nodeptr_st {
    node_st			*ptr;
    nodeptr_st		*next;
  } nodeptr;

  Block<node>			*node_block;
  Block<arc>			*arc_block;
  DBlock<nodeptr>		*nodeptr_block;

  void	(*error_function)(const char *);/* this function is called if a error occurs,
                                           with a corresponding error message
                                           (or exit(1) is called if it's NULL) */

  flowtype			flow;		/* total flow */

  node				*queue_first[2], *queue_last[2];	/* list of active nodes */
  nodeptr			*orphan_first, *orphan_last;		/* list of pointers to orphans */
  int				TIME;					/* monotonically increasing global counter */

  void set_active(node *i);
  node *next_active();

  void maxflow_init();
  void augment(arc *middle_arc);
  void process_source_orphan(node *i);
  void process_sink_orphan(node *i);
};

#endif
```

```
/* graphcut.cpp */
#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

extern "C" {
#include "compter.h"
#include "main.h"
#include "texturize.h"
}
#include "graph.h"

#define MAX_CAPACITY 16383 // Half of the largest short, (captype is short in graph.h)
#define REMPLI    1
#define CUT_NORTH 2
#define CUT_WEST  4
#define HAS_CUT_NORTH(r) (r) & CUT_NORTH
#define HAS_CUT_WEST(r)  (r) & CUT_WEST

// ||pixel1 - pixel2||^2
// From experience, squares seem to work better than another type of norm.
inline Graph::captype cost (unsigned char * pixel1, unsigned char * pixel2, int channels) {
  int diff, result = 0;
  for (int c = 0; c < channels; c++){
    diff = pixel1[c] - pixel2[c];
    result += diff*diff;
  }
  return (result/24);
  // We need to divide at least by 24, or we might return more than
  // MAX_CAPACITY.
}

inline Graph::captype gradient (unsigned char * pixel1, unsigned char * pixel2, int channels) {
  int diff, result = 0;
  for (int c = 0; c < channels; c++){
    diff = pixel1[c] - pixel2[c];
    result += diff*diff;
  }
  return ((Graph::captype) sqrt(result));
}

// When we write the four arguments to edge_weight on two lines of code,
// we try to always align things (pixel VS image) so that it makes sense.
inline Graph::captype edge_weight (int channels,
                                   unsigned char * im1_pix1, unsigned char * im2_pix1,
                                   unsigned char * im1_pix2, unsigned char * im2_pix2) {
  return ((cost(im1_pix1,im2_pix1,channels) + (cost(im1_pix2,im2_pix2,channels)))
          / (gradient(im1_pix1,im1_pix2,channels) + gradient(im2_pix1,im2_pix2,channels) +1));
}

inline void paste_patch_pixel_to_image(int width_i, int height_i, int width_p, int height_p,
                                       int x_i, int y_i, int x_p, int y_p,
                                       int channels,
                                       unsigned char * image, unsigned char * patch) {
  int k;
  for (k = 0; k < channels; k++) {
    image[(y_i * width_i + x_i) * channels + k] = patch[(y_p * width_p + x_p) * channels + k];
  }
}

void decoupe_graphe (int* patch_posn,
                     int width_i, int height_i, int width_p, int height_p,
                     int channels,
                     unsigned char  **rempli,
                     unsigned char   *image, unsigned char * patch,
                     unsigned char   *coupe_h_here, unsigned char * coupe_h_west,
                     unsigned char   *coupe_v_here, unsigned char * coupe_v_north,
                     bool  make_tileable, bool invert) {

  int k, x_p, y_p, x_i, y_i;// nb_sommets, sommet_courant; // Compteurs
  int real_x_i, real_y_i;
  int x_inf, y_inf, x_sup, y_sup;
  Graph * graphe = new Graph(); // Le graphe à couper
  Graph::node_id *node_of_pixel = (void **) calloc (width_p * height_p, sizeof (Graph::node_id)); // Le noeud du graph auquel correspond un pointeur.
  for (k=0; k<width_p * height_p; k++) node_of_pixel[k] = NULL;

  Graph::captype poids; // Pour calculer le poids d'un arc avant de le déclarer à Graph:add_edge
  Graph::node_id first_node = NULL, node_sommet_courant;
  unsigned char r;

  if (make_tileable) {
    x_inf = patch_posn[0];
    y_inf = patch_posn[1];
    x_sup = patch_posn[0] + width_p;
    y_sup = patch_posn[1] + height_p;
  } else {
    x_inf = MAX (0, patch_posn[0]);
    y_inf = MAX (0, patch_posn[1]);
    x_sup = MIN (width_i,  patch_posn[0] + width_p);
    y_sup = MIN (height_i, patch_posn[1] + height_p);
  }

  for (real_x_i = x_inf;
       real_x_i < x_sup;
       real_x_i++) {
    x_p = real_x_i - patch_posn[0];
    x_i = modulo (real_x_i, width_i);
    for (real_y_i = y_inf;
         real_y_i < y_sup;
         real_y_i++) {
      y_p = real_y_i - patch_posn[1];
      y_i = modulo (real_y_i, height_i);

      // Si le pixel de l'image n'est pas rempli, on ne fait rien et on passe au suivant
      if (rempli[x_i][y_i]) {
        node_of_pixel[x_p * height_p + y_p] = graphe->add_node ();
        if (first_node == NULL) first_node = node_of_pixel[x_p * height_p + y_p];
      }
    }
  }

  for (real_x_i = x_inf;
       real_x_i < x_sup;
       real_x_i++) {
    x_p = real_x_i - patch_posn[0];
    x_i = modulo (real_x_i, width_i);

    for (real_y_i = y_inf;
         real_y_i < y_sup;
         real_y_i++) {
      y_p = real_y_i - patch_posn[1];
      y_i = modulo (real_y_i, height_i);

      // If the pixel in the image hasn't been filled, we do nothing and skip
      // to the next one.
      if (!rempli[x_i][y_i]) {
        continue;
      } else {
        // Create the nodes and edges.
        node_sommet_courant = node_of_pixel[x_p * height_p + y_p];

        // If the neighbord exists in the patch and if the pixel to the North
        // is filled in the image, create a link to it.
        if ((!make_tileable && y_p != 0 && y_i != 0 && rempli[x_i][y_i - 1])
          || (make_tileable && y_p != 0 && rempli[x_i][modulo (y_i - 1, height_i)])) {
          poids = edge_weight (channels,
                               image + ((y_i * width_i + x_i) * channels),
                               patch + ((y_p * width_p + x_p) * channels),
                               image + (((modulo (y_i - 1, height_i)) * width_i + x_i) * channels),
                               patch + (((y_p - 1) * width_p + x_p) * channels));
          graphe->add_edge (node_sommet_courant,
                            node_of_pixel[x_p * height_p + y_p - 1],
                            poids, poids);
        }

        // If the West neighbor exists in the patch and if the West pixel is
        // filled in the image, we create a link to it.
        if ((!make_tileable && x_p != 0 && x_i != 0 && rempli[x_i - 1][y_i])
          || (make_tileable && x_p != 0 && rempli[modulo (x_i - 1, width_i)][y_i])) {
          poids = edge_weight (channels,
                               image + ((y_i * width_i + x_i) * channels),
                               patch + ((y_p * width_p + x_p) * channels),
                               image + ((y_i * width_i + (modulo (x_i, width_i) - 1)) * channels),
                               patch + ((y_p * width_p + (x_p - 1)) * channels));
          graphe->add_edge (node_sommet_courant,
                            node_of_pixel[(x_p - 1) * height_p + y_p],
                            poids, poids);
        }

        // If I am on the edge of the patch and, if !make_tileable, I am not on
        // the edge of the image, link me to the source.
       if (    (make_tileable && (x_p == 0 || y_p == 0 || x_p == width_p - 1 || y_p == height_p - 1))
            || (!make_tileable && (x_p == 0 || y_p == 0 || x_p == width_p - 1 || y_p == height_p - 1)
		               &&  x_i != 0 && y_i != 0 && x_i != width_i - 1 && y_i != height_i - 1)) {
          graphe->add_tweights (node_sommet_courant, MAX_CAPACITY, 0);
	}

        // If one of my neighbords exists and isn't filled, link me to the sink.
        if (((!make_tileable)
              && (  (y_p != 0            && y_i != 0            && !rempli[x_i][y_i - 1])      // North
                 || (y_p != height_p - 1 && y_i != height_i - 1 && !rempli[x_i][y_i + 1])      // South
                 || (x_p != width_p - 1  && x_i != width_i - 1  && !rempli[x_i + 1][y_i])      // East
                 || (x_p != 0            && x_i != 0            && !rempli[x_i - 1][y_i])))    // West
            || ((make_tileable)
              && (  (y_p != 0            && !rempli[x_i][modulo (y_i - 1, height_i)])          // North
                 || (y_p != height_p - 1 && !rempli[x_i][modulo (y_i + 1, height_i)])          // South
                 || (x_p != width_p - 1  && !rempli[modulo (x_i + 1, width_i)][y_i])           // East
                 || (x_p != 0            && !rempli[modulo (x_i - 1, width_i)][y_i])))) {      // West
          graphe->add_tweights (node_sommet_courant, 0, MAX_CAPACITY);
	}
      }
    }
  }

  // If !make_tileable, link the top left pixel in patch \cap image to the
  // source.
  if (!make_tileable) {
    graphe->add_tweights (first_node, MAX_CAPACITY, 0);
  }

  graphe->maxflow();

  for (real_x_i = x_inf; real_x_i < x_sup; real_x_i++) {
    x_p = real_x_i - patch_posn[0];
    x_i = modulo (real_x_i, width_i);
    for (real_y_i = y_inf; real_y_i < y_sup; real_y_i++) {
      y_p = real_y_i - patch_posn[1];
      y_i = modulo (real_y_i, height_i);
      r = rempli[x_i][y_i];
      if (r) {
        if (graphe->what_segment(node_of_pixel[x_p * height_p + y_p]) == Graph::SINK) {
          paste_patch_pixel_to_image (width_i, height_i, width_p, height_p, x_i, y_i, x_p, y_p,
                                      channels, image, patch);
	}
      } else {
        paste_patch_pixel_to_image (width_i, height_i, width_p, height_p, x_i, y_i, x_p, y_p,
                                    channels, image, patch)
        rempli[x_i][y_i] = REMPLI;
      }
    }
  }

  delete graphe;
  free (node_of_pixel);

  return;
}
```

```
/* initializer.h */
#include <stdlib.h>
#include "texturize.h"

// Allocates enough memory for a 2-dimensional table of unsigned chars and
// initializes all elements to zero.
unsigned char ** init_guchar_tab_2d(int x, int y) {
  unsigned char ** tab;
  int i, j;
  tab = (unsigned char**) malloc (x * sizeof (unsigned char*));

  for (i = 0; i < x; i++) {
    tab[i] = (unsigned char*) malloc (y * sizeof (unsigned char));
  }

  for (i = 0; i < x; i++) {
    for (j = 0; j < y; j++) tab[i][j] = 0;
  }
  return tab;
}
```

```
/* main.cpp */
#include <opencv2/opencv.hpp>
#include "texturize.h"

int main(int argc, char** argv) {
    if (argc != 5) {
        std::cerr << "Usage: " << argv[0] << " <input_image> <output_image> <output_width> <output_height>" << std::endl;
        return -1;
    }

    std::string input_image_path = argv[1];
    std::string output_image_path = argv[2];
    int output_width = std::stoi(argv[3]);
    int output_height = std::stoi(argv[4]);

    cv::Mat input_image = cv::imread(input_image_path, cv::IMREAD_COLOR);
    if (input_image.empty()) {
        std::cerr << "Error: Could not open or find the image!" << std::endl;
        return -1;
    }

    cv::Mat output_image(output_height, output_width, input_image.type());

    // Initialize the filled matrix
    unsigned char** filled = init_guchar_tab_2d(output_width, output_height);

    // Initialize the patch and image buffers
    int channels = input_image.channels();
    unsigned char* patch = input_image.data;
    unsigned char* image = output_image.data;

    // Initialize the coupe buffers
    unsigned char* coupe_h_here = new unsigned char[output_width * output_height * channels];
    unsigned char* coupe_h_west = new unsigned char[output_width * output_height * channels];
    unsigned char* coupe_v_here = new unsigned char[output_width * output_height * channels];
    unsigned char* coupe_v_north = new unsigned char[output_width * output_height * channels];

    // Initialize the first patch
    for (int x = 0; x < input_image.cols; ++x) {
        for (int y = 0; y < input_image.rows; ++y) {
            for (int c = 0; c < channels; ++c) {
                image[(y * output_width + x) * channels + c] = patch[(y * input_image.cols + x) * channels + c];
            }
            filled[x][y] = 1;
        }
    }

    // Main texture synthesis loop
    int cur_posn[2] = {0, 0};
    int patch_posn[2];
    while (count_filled_pixels(filled, output_width, output_height) < output_width * output_height) {
        if (pixel_to_fill(filled, output_width, output_height, cur_posn) == NULL) {
            std::cerr << "Error: Could not find the next pixel to fill!" << std::endl;
            return -1;
        }

        offset_optimal(patch_posn, image, patch, input_image.cols, input_image.rows, output_width, output_height,
                       cur_posn[0] - 10, cur_posn[1] - 10, cur_posn[0] + 10, cur_posn[1] + 10, channels, filled, false);

        decoupe_graphe(patch_posn, output_width, output_height, input_image.cols, input_image.rows, channels, filled,
                       image, patch, coupe_h_here, coupe_h_west, coupe_v_here, coupe_v_north, false, false);
    }

    // Save the output image
    cv::imwrite(output_image_path, output_image);

    // Clean up
    delete[] coupe_h_here;
    delete[] coupe_h_west;
    delete[] coupe_v_here;
    delete[] coupe_v_north;
    for (int i = 0; i < output_width; ++i) {
        delete[] filled[i];
    }
    delete[] filled;

    return 0;
}
```

```
/* maxflow.cpp */

#include <stdio.h>
#include "graph.h"

/*
  special constants for node->parent
*/
#define TERMINAL ( (arc *) 1 )		/* to terminal */
#define ORPHAN   ( (arc *) 2 )		/* orphan */

#define INFINITE_D 1000000000		/* infinite distance to the terminal */

inline void Graph::set_active(node *i) {
  if (!i->next) {
    /* it's not in the list yet */
    if (queue_last[1]) queue_last[1] -> next = i;
    else               queue_first[1]        = i;
    queue_last[1] = i;
    i -> next = i;
  }
}

inline Graph::node * Graph::next_active() {
  node *i;

  while ( 1 ) {
    if (!(i=queue_first[0])) {
      queue_first[0] = i = queue_first[1];
      queue_last[0]  = queue_last[1];
      queue_first[1] = NULL;
      queue_last[1]  = NULL;
      if (!i) return NULL;
    }

    /* remove it from the active list */
    if (i->next == i) queue_first[0] = queue_last[0] = NULL;
    else              queue_first[0] = i -> next;
    i -> next = NULL;

    /* a node in the list is active iff it has a parent */
    if (i->parent) return i;
  }
}

void Graph::maxflow_init() {
  node *i;

  queue_first[0] = queue_last[0] = NULL;
  queue_first[1] = queue_last[1] = NULL;
  orphan_first = NULL;

  for (i=node_block->ScanFirst(); i; i=node_block->ScanNext()) {
    i -> next = NULL;
    i -> TS = 0;
    if (i->tr_cap > 0) {
      /* i is connected to the source */
      i -> is_sink = 0;
      i -> parent = TERMINAL;
      set_active(i);
      i -> TS = 0;
      i -> DIST = 1;
    } else if (i->tr_cap < 0) {
      /* i is connected to the sink */
      i -> is_sink = 1;
      i -> parent = TERMINAL;
      set_active(i);
      i -> TS = 0;
      i -> DIST = 1;
    } else {
      i -> parent = NULL;
    }
  }
  TIME = 0;
}

void Graph::augment(arc *middle_arc) {
  node *i;
  arc *a;
  captype bottleneck;
  nodeptr *np;


  /* 1. Finding bottleneck capacity */
  /* 1a - the source tree */
  bottleneck = middle_arc -> r_cap;
  for (i=middle_arc->sister->head; ; i=a->head) {
    a = i -> parent;
    if (a == TERMINAL) break;
    if (bottleneck > a->sister->r_cap) bottleneck = a -> sister -> r_cap;
  }
  if (bottleneck > i->tr_cap) bottleneck = i -> tr_cap;
  /* 1b - the sink tree */
  for (i=middle_arc->head; ; i=a->head)	{
    a = i -> parent;
    if (a == TERMINAL) break;
    if (bottleneck > a->r_cap) bottleneck = a -> r_cap;
  }
  if (bottleneck > - i->tr_cap) bottleneck = - i -> tr_cap;

  /* 2. Augmenting */
  /* 2a - the source tree */
  middle_arc -> sister -> r_cap += bottleneck;
  middle_arc -> r_cap -= bottleneck;
  for (i=middle_arc->sister->head; ; i=a->head) {
    a = i -> parent;
    if (a == TERMINAL) break;
    a -> r_cap += bottleneck;
    a -> sister -> r_cap -= bottleneck;
    if (!a->sister->r_cap) {
      /* add i to the adoption list */
      i -> parent = ORPHAN;
      np = nodeptr_block -> New();
      np -> ptr = i;
      np -> next = orphan_first;
      orphan_first = np;
    }
  }
  i -> tr_cap -= bottleneck;
  if (!i->tr_cap) {
    /* add i to the adoption list */
    i -> parent = ORPHAN;
    np = nodeptr_block -> New();
    np -> ptr = i;
    np -> next = orphan_first;
    orphan_first = np;
  }
  /* 2b - the sink tree */
  for (i=middle_arc->head; ; i=a->head) {
    a = i -> parent;
    if (a == TERMINAL) break;
    a -> sister -> r_cap += bottleneck;
    a -> r_cap -= bottleneck;
    if (!a->r_cap) {
        /* add i to the adoption list */
      i -> parent = ORPHAN;
      np = nodeptr_block -> New();
      np -> ptr = i;
      np -> next = orphan_first;
      orphan_first = np;
    }
  }
  i -> tr_cap += bottleneck;
  if (!i->tr_cap) {
    /* add i to the adoption list */
    i -> parent = ORPHAN;
    np = nodeptr_block -> New();
    np -> ptr = i;
    np -> next = orphan_first;
    orphan_first = np;
  }

  flow += bottleneck;
}

void Graph::process_source_orphan(node *i) {
  node *j;
  arc *a0, *a0_min = NULL, *a;
  nodeptr *np;
  int d, d_min = INFINITE_D;

  /* trying to find a new parent */
  for (a0=i->first; a0; a0=a0->next)
    if (a0->sister->r_cap) {
      j = a0 -> head;
      if (!j->is_sink && (a=j->parent)) {
        /* checking the origin of j */
        d = 0;
        while ( 1 ) {
          if (j->TS == TIME) {
            d += j -> DIST;
            break;
          }
          a = j -> parent;
          d ++;
          if (a==TERMINAL) {
            j -> TS = TIME;
            j -> DIST = 1;
            break;
          }
          if (a==ORPHAN) { d = INFINITE_D; break; }
          j = a -> head;
        }
        if (d<INFINITE_D) {
          /* j originates from the source - done */
          if (d<d_min) {
            a0_min = a0;
            d_min = d;
          }
          /* set marks along the path */
          for (j=a0->head; j->TS!=TIME; j=j->parent->head) {
            j -> TS = TIME;
            j -> DIST = d --;
          }
        }
      }
    }

  if ((i->parent = a0_min)) {
    i -> TS = TIME;
    i -> DIST = d_min + 1;
  } else {
    /* no parent is found */
    i -> TS = 0;

    /* process neighbors */
    for (a0=i->first; a0; a0=a0->next) {
      j = a0 -> head;
      if (!j->is_sink && (a=j->parent)) {
        if (a0->sister->r_cap) set_active(j);
        if (a!=TERMINAL && a!=ORPHAN && a->head==i) {
          /* add j to the adoption list */
          j -> parent = ORPHAN;
          np = nodeptr_block -> New();
          np -> ptr = j;
          if (orphan_last) orphan_last -> next = np;
          else             orphan_first        = np;
          orphan_last = np;
          np -> next = NULL;
        }
      }
    }
  }
}

void Graph::process_sink_orphan(node *i) {
  node *j;
  arc *a0, *a0_min = NULL, *a;
  nodeptr *np;
  int d, d_min = INFINITE_D;

  /* trying to find a new parent */
  for (a0=i->first; a0; a0=a0->next)
    if (a0->r_cap) {
      j = a0 -> head;
      if (j->is_sink && (a=j->parent)) {
        /* checking the origin of j */
        d = 0;
        while ( 1 ) {
          if (j->TS == TIME) {
            d += j -> DIST;
            break;
          }
          a = j -> parent;
          d ++;
          if (a==TERMINAL) {
            j -> TS = TIME;
            j -> DIST = 1;
            break;
          }
          if (a==ORPHAN) { d = INFINITE_D; break; }
          j = a -> head;
        }
        if (d<INFINITE_D) { /* j originates from the sink - done */
          if (d < d_min) {
            a0_min = a0;
            d_min = d;
          }
          /* set marks along the path */
          for (j=a0->head; j->TS!=TIME; j=j->parent->head) {
            j -> TS = TIME;
            j -> DIST = d --;
          }
        }
      }
    }

  if ((i->parent = a0_min)) {
    i -> TS = TIME;
    i -> DIST = d_min + 1;
  } else {
    /* no parent is found */
    i -> TS = 0;

    /* process neighbors */
    for (a0=i->first; a0; a0=a0->next) {
      j = a0 -> head;
      if (j->is_sink && (a=j->parent)) {
        if (a0->r_cap) set_active(j);
        if (a!=TERMINAL && a!=ORPHAN && a->head==i) {
          /* add j to the adoption list */
          j -> parent = ORPHAN;
          np = nodeptr_block -> New();
          np -> ptr = j;
          if (orphan_last) orphan_last -> next = np;
          else             orphan_first        = np;
          orphan_last = np;
          np -> next = NULL;
        }
      }
    }
  }
}

Graph::flowtype Graph::maxflow() {
  node *i, *j, *current_node = NULL;
  arc *a;
  nodeptr *np, *np_next;

  maxflow_init();
  nodeptr_block = new DBlock<nodeptr>(NODEPTR_BLOCK_SIZE, error_function);

  while ( 1 ) {
    if ((i = current_node)) {
      i -> next = NULL; /* remove active flag */
      if (!i->parent) i = NULL;
    }
    if (!i) {
      if (!(i = next_active())) break;
    }

    /* growth */
    if (!i->is_sink) {
      /* grow source tree */
      for (a = i->first; a; a = a->next)
        if (a->r_cap) {
          j = a -> head;
          if (!j->parent) {
            j -> is_sink = 0;
            j -> parent = a -> sister;
            j -> TS = i -> TS;
            j -> DIST = i -> DIST + 1;
            set_active(j);
          } else if (j->is_sink) break;
          else if (j->TS <= i->TS && j->DIST > i->DIST) {
            /* heuristic - trying to make the distance from j to the source shorter */
            j -> parent = a -> sister;
            j -> TS = i -> TS;
            j -> DIST = i -> DIST + 1;
          }
        }
    } else {
      /* grow sink tree */
      for (a=i->first; a; a=a->next)
        if (a->sister->r_cap) {
          j = a -> head;
          if (!j->parent) {
            j -> is_sink = 1;
            j -> parent = a -> sister;
            j -> TS = i -> TS;
            j -> DIST = i -> DIST + 1;
            set_active(j);
          } else if (!j->is_sink) { a = a -> sister; break; }
          else if (j->TS <= i->TS && j->DIST > i->DIST) {
            /* heuristic - trying to make the distance from j to the sink shorter */
            j -> parent = a -> sister;
            j -> TS = i -> TS;
            j -> DIST = i -> DIST + 1;
          }
        }
    }

    TIME ++;

    if (a) {
      i -> next = i; /* set active flag */
      current_node = i;

      /* augmentation */
      augment(a);
      /* augmentation end */

      /* adoption */
      while ((np = orphan_first)) {
        np_next = np -> next;
        np -> next = NULL;

        while ((np = orphan_first)) {
          orphan_first = np -> next;
          i = np -> ptr;
          nodeptr_block -> Delete(np);
          if (!orphan_first) orphan_last = NULL;
          if (i->is_sink) process_sink_orphan(i);
          else            process_source_orphan(i);
        }

        orphan_first = np_next;
      }
      /* adoption end */
    }
    else current_node = NULL;
  }

  delete nodeptr_block;

  return flow;
}

Graph::termtype Graph::what_segment(node_id i) {
  if (((node*)i)->parent && !((node*)i)->is_sink) return SOURCE;
  return SINK;
}
```

```
/* offset.c */
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <glib.h>

#include "main.h"
#include "texturize.h"

#include "plugin-intl.h"

float difference(int width_i, int height_i, int width_p, int height_p,
                 unsigned char * image, unsigned char * patch,
                 int posn_x, int posn_y,
                 int x_min, int y_min, int x_max, int y_max,
                 int channels, unsigned char ** filled) {

  int    somme = 0, zone=0;
  int    x_i, y_i, k;
  unsigned char *image_ptr, *patch_ptr;

  int x_p, y_p;
  int x_i_start, x_p_start;
  int xcount, ycount;
  int iy, ix;
  unsigned char *image_ptr_x, *patch_ptr_x;
  int image_add_y, patch_add_y;

  // source image edges is looping

  ycount = y_max - y_min;
  xcount = x_max - x_min;

  y_i = modulo(y_min, height_i);
  x_i_start = modulo(x_min, width_i);

  y_p = modulo(y_i - posn_y, height_p);
  x_p_start = modulo(x_i_start - posn_x, width_p);

  image_add_y = width_i * channels;
  patch_add_y = width_p * channels;
  image_ptr_x = image + y_i * image_add_y;
  patch_ptr_x = patch + y_p * patch_add_y;

  for (iy = 0; iy < ycount; iy++) {

    x_i = x_i_start;
    x_p = x_p_start;
    image_ptr = image_ptr_x + x_i * channels;
    patch_ptr = patch_ptr_x + x_p * channels;

    for (ix = 0; ix < xcount; ix++) {
      if (filled[x_i][y_i]) {
        for (k = 0 ; k < channels; k++) {
          somme += abs (*image_ptr - *patch_ptr);
          image_ptr++;
          patch_ptr++;
          zone++;
        }
      } else {
        image_ptr += channels;
        patch_ptr += channels;
      }

      if (++x_i >= width_i) { x_i = 0; image_ptr = image_ptr_x; }
      if (++x_p >= width_p) { x_p = 0; patch_ptr = patch_ptr_x; }
    }

    image_ptr_x += image_add_y;
    patch_ptr_x += patch_add_y;

    if (++y_i >= height_i) { y_i = 0; image_ptr_x = image; }
    if (++y_p >= height_p) { y_p = 0; patch_ptr_x = patch; }
  }

    if (zone == 0) {
        std::cerr << "Bug: Zone = 0" << std::endl;
        std::cerr << "No filled pixels in the overlapping region." << std::endl;
        std::cerr << "posn_x: " << posn_x << ", posn_y: " << posn_y << std::endl;
        std::cerr << "x_min: " << x_min << ", y_min: " << y_min << std::endl;
        std::cerr << "x_max: " << x_max << ", y_max: " << y_max << std::endl;
        exit(-1);
    }
  return (((float) somme) / ((float) zone));
}

void offset_optimal(int *resultat, unsigned char *image, unsigned char *patch,
                    int width_p, int height_p, int width_i, int height_i,
                    int x_patch_posn_min, int y_patch_posn_min, int x_patch_posn_max, int y_patch_posn_max,
                    int channels, unsigned char **filled, bool tileable) {
    int x_i, y_i;
    float best_difference = INFINITY, tmp_difference;

    if (tileable) {
        for (x_i = x_patch_posn_min; x_i < x_patch_posn_max; x_i++) {
            for (y_i = y_patch_posn_min; y_i < y_patch_posn_max; y_i++) {
                // Ensure valid patch position
                if (x_i < 0 || y_i < 0 || x_i >= width_i || y_i >= height_i) continue;

                tmp_difference = difference(width_i, height_i, width_p, height_p, image, patch,
                                            x_i, y_i, std::max(0, x_i), std::max(0, y_i),
                                            x_i + width_p, y_i + height_p, channels, filled);

                if (tmp_difference < best_difference) {
                    best_difference = tmp_difference;
                    resultat[0] = x_i; resultat[1] = y_i;
                }
            }
        }
    } else {
        for (x_i = x_patch_posn_min; x_i < x_patch_posn_max; x_i++) {
            for (y_i = y_patch_posn_min; y_i < y_patch_posn_max; y_i++) {
                // Ensure valid patch position
                if (x_i < 0 || y_i < 0 || x_i >= width_i || y_i >= height_i) continue;

                tmp_difference = difference(width_i, height_i, width_p, height_p, image, patch,
                                            x_i, y_i, std::max(0, x_i), std::max(0, y_i),
                                            std::min(x_i + width_p, width_i), std::min(y_i + height_p, height_i),
                                            channels, filled);

                if (tmp_difference < best_difference) {
                    best_difference = tmp_difference;
                    resultat[0] = x_i; resultat[1] = y_i;
                }
            }
        }
    }
}
```

```
/* texturize.cpp */
#include "texturize.h"
#include <opencv2/opencv.hpp>
#include <cmath>
#include <cstdlib>
#include <iostream>

int modulo(int x, int m) {
  int v = (x - (m * (x / m)));
  return (v >= 0)? v : v + m;
}

// Computes the distance between image_tab and patch_tab for the zone that's been filled in:
// (x_min,y_min) -> (x_max,y_max) in image_tab
// (x_min,y_min)-posn -> (x_max,y_max) - posn in patch_tab
float difference(int width_i, int height_i, int width_p, int height_p,
                 unsigned char *image, unsigned char *patch, int posn_x, int posn_y,
                 int x_min, int y_min, int x_max, int y_max,
                 int channels, unsigned char **filled) {

    int somme = 0, zone = 0;
    int x_i, y_i, k;
    unsigned char *image_ptr, *patch_ptr;

    int x_p, y_p;
    int x_i_start, x_p_start;
    int xcount, ycount;
    int iy, ix;
    unsigned char *image_ptr_x, *patch_ptr_x;
    int image_add_y, patch_add_y;

    // Debugging output
    std::cout << "difference function called with parameters:" << std::endl;
    std::cout << "posn_x: " << posn_x << ", posn_y: " << posn_y << std::endl;
    std::cout << "x_min: " << x_min << ", y_min: " << y_min << std::endl;
    std::cout << "x_max: " << x_max << ", y_max: " << y_max << std::endl;

    ycount = y_max - y_min;
    xcount = x_max - x_min;

    y_i = modulo(y_min, height_i);
    x_i_start = modulo(x_min, width_i);

    y_p = modulo(y_i - posn_y, height_p);
    x_p_start = modulo(x_i_start - posn_x, width_p);

    image_add_y = width_i * channels;
    patch_add_y = width_p * channels;
    image_ptr_x = image + y_i * image_add_y;
    patch_ptr_x = patch + y_p * patch_add_y;

    for (iy = 0; iy < ycount; iy++) {

        x_i = x_i_start;
        x_p = x_p_start;
        image_ptr = image_ptr_x + x_i * channels;
        patch_ptr = patch_ptr_x + x_p * channels;

        for (ix = 0; ix < xcount; ix++) {
            if (filled[x_i][y_i]) {
                for (k = 0; k < channels; k++) {
                    somme += abs(*image_ptr - *patch_ptr);
                    image_ptr++;
                    patch_ptr++;
                    zone++;
                }
            } else {
                image_ptr += channels;
                patch_ptr += channels;
            }

            if (++x_i >= width_i) { x_i = 0; image_ptr = image_ptr_x; }
            if (++x_p >= width_p) { x_p = 0; patch_ptr = patch_ptr_x; }
        }

        image_ptr_x += image_add_y;
        patch_ptr_x += patch_add_y;

        if (++y_i >= height_i) { y_i = 0; image_ptr_x = image; }
        if (++y_p >= height_p) { y_p = 0; patch_ptr_x = patch; }
    }

    if (zone == 0) {
        std::cerr << "Bug: Zone = 0" << std::endl;
        std::cerr << "No filled pixels in the overlapping region." << std::endl;
        std::cerr << "posn_x: " << posn_x << ", posn_y: " << posn_y << std::endl;
        std::cerr << "x_min: " << x_min << ", y_min: " << y_min << std::endl;
        std::cerr << "x_max: " << x_max << ", y_max: " << y_max << std::endl;
        exit(-1);
    }
    return (((float) somme) / ((float) zone));
}

void offset_optimal(int *resultat, unsigned char *image, unsigned char *patch,
                    int width_p, int height_p, int width_i, int height_i,
                    int x_patch_posn_min, int y_patch_posn_min, int x_patch_posn_max, int y_patch_posn_max,
                    int channels, unsigned char **filled, bool tileable) {
    int x_i, y_i;
    float best_difference = INFINITY, tmp_difference;

    if (tileable) {
        for (x_i = x_patch_posn_min; x_i < x_patch_posn_max; x_i++) {
            for (y_i = y_patch_posn_min; y_i < y_patch_posn_max; y_i++) {
                // Ensure valid patch position
                if (x_i < 0 || y_i < 0 || x_i >= width_i || y_i >= height_i) continue;

                tmp_difference = difference(width_i, height_i, width_p, height_p, image, patch,
                                            x_i, y_i, std::max(0, x_i), std::max(0, y_i),
                                            x_i + width_p, y_i + height_p, channels, filled);

                if (tmp_difference < best_difference) {
                    best_difference = tmp_difference;
                    resultat[0] = x_i; resultat[1] = y_i;
                }
            }
        }
    } else {
        for (x_i = x_patch_posn_min; x_i < x_patch_posn_max; x_i++) {
            for (y_i = y_patch_posn_min; y_i < y_patch_posn_max; y_i++) {
                // Ensure valid patch position
                if (x_i < 0 || y_i < 0 || x_i >= width_i || y_i >= height_i) continue;

                tmp_difference = difference(width_i, height_i, width_p, height_p, image, patch,
                                            x_i, y_i, std::max(0, x_i), std::max(0, y_i),
                                            std::min(x_i + width_p, width_i), std::min(y_i + height_p, height_i),
                                            channels, filled);

                if (tmp_difference < best_difference) {
                    best_difference = tmp_difference;
                    resultat[0] = x_i; resultat[1] = y_i;
                }
            }
        }
    }
}
```

```
/* texturize.h */
#ifndef TEXTURIZE_H
#define TEXTURIZE_H

#include <opencv2/opencv.hpp>

// Counts number of cells != 0 in filled.
int count_filled_pixels(unsigned char **filled, int width_i, int height_i);

// Compute the graph, cuts it and updates the image.
void decoupe_graphe(
    int* patch_posn, // Where to put the patch.
    int width_i, int height_i, int width_p, int height_p,
    int channels,
    unsigned char **filled, // Tells whether the pixel is filled and if there is a cut here.
    unsigned char *image, unsigned char *patch,
    unsigned char *coupe_h_here, unsigned char *coupe_h_west,   // Pixels lost along an old horizontal cut
    unsigned char *coupe_v_here, unsigned char *coupe_v_north,  // idem for vertical cuts
    bool make_tileable, bool invert);

// Allocates the memory (with malloc) and fills with 0.
unsigned char **init_guchar_tab_2d(int x, int y);

/* Compute the best position to put the patch,
 * between (x_patch_posn_min, y_patch_posn_min)
 * and     (x_patch_posn_max, y_patch_posn_max).
 */
void offset_optimal(
    int *resultat, // The position where the patch will have to be put.
    unsigned char *image, unsigned char *patch,
    int width_p, int height_p, int width_i, int height_i,
    int x_patch_posn_min, int y_patch_posn_min, int x_patch_posn_max, int y_patch_posn_max,
    // Admissible positions for the patch, this function determines the best one.
    int channels,
    unsigned char **filled,
    bool make_tileable);

// Returns the minimal unfilled pixel under lexicographical order (y,x).
int *pixel_to_fill(unsigned char **filled, int width_i, int height_i, int *resultat);

int modulo(int x, int m);

#endif // TEXTURIZE_H
```